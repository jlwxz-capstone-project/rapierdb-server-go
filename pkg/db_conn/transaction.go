package db_conn

import (
	"bytes"

	"github.com/jlwxz-capstone-project/rapierdb-server-go/pkg/util"
)

type Transaction struct {
	// Transaction ID, should be a UUID, generated by the client
	TxID       string
	Committer  string // Committer, should be client's id
	Operations []TransactionOp
}

// writeTransaction writes a transaction to a buffer
func writeTransaction(buf *bytes.Buffer, tr *Transaction) error {
	if err := util.WriteVarString(buf, tr.TxID); err != nil {
		return err
	}
	if err := util.WriteVarString(buf, tr.Committer); err != nil {
		return err
	}
	if err := util.WriteVarUint(buf, uint64(len(tr.Operations))); err != nil {
		return err
	}
	for _, op := range tr.Operations {
		if err := writeTransactionOp(buf, op); err != nil {
			return err
		}
	}
	return nil
}

// EncodeTransaction encodes a transaction to bytes
func EncodeTransaction(tr *Transaction) (res []byte, err error) {
	buf := bytes.NewBuffer(nil)
	err = writeTransaction(buf, tr)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// ReadTransaction reads a transaction from a buffer
func ReadTransaction(data *bytes.Buffer) (*Transaction, error) {
	txID, err := util.ReadVarString(data)
	if err != nil {
		return nil, err
	}
	committer, err := util.ReadVarString(data)
	if err != nil {
		return nil, err
	}
	nOperations, err := util.ReadVarUint(data)
	if err != nil {
		return nil, err
	}

	operations := make([]TransactionOp, 0, nOperations)
	for i := uint64(0); i < nOperations; i++ {
		op, err := readTransactionOp(data)
		if err != nil {
			return nil, err // Propagate error
		}
		operations = append(operations, op)
	}

	return &Transaction{
		TxID:       txID,
		Committer:  committer,
		Operations: operations,
	}, nil
}

// DecodeTransaction decodes a transaction from bytes
func DecodeTransaction(data []byte) (res *Transaction, err error) {
	buf := bytes.NewBuffer(data)
	res, err = ReadTransaction(buf)
	return res, err
}
